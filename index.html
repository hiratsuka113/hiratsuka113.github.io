<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Delayed Camera (Strong RGB Split)</title>
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; }
    canvas { width:100%; height:100%; display:block; }
    .ui {
      position:fixed; top:10px; left:10px;
      color:#fff; font-family: ui-monospace, Menlo, monospace;
      background: rgba(0,0,0,0.35); padding:10px 12px;
      border:1px solid rgba(255,255,255,0.25); border-radius: 12px;
      line-height: 1.35;
      user-select: none;
    }
    .row { margin-top: 8px; }
    label { display:block; font-size: 12px; opacity: 0.9; margin-bottom: 4px; }
    input[type="range"] { width: 280px; }
    .pill {
      display:inline-block; padding:4px 8px; border:1px solid rgba(255,255,255,0.25);
      border-radius: 999px; font-size: 12px; opacity:0.9;
    }
    button {
      margin-top: 8px;
      padding:6px 10px;
      border:1px solid rgba(255,255,255,0.25);
      border-radius:10px;
      background: rgba(255,255,255,0.06);
      color:#fff;
      font-family: inherit;
    }
  </style>
</head>
<body>
  <canvas id="cv"></canvas>

  <div class="ui">
    <div class="pill">LIVE</div>
    <div>Delay: <b><span id="msNow">---</span></b> ms / RGB Shift: <b><span id="rgbNow">---</span></b> px</div>

    <div class="row">
      <label>遅延の下限 (min ms): <span id="minLabel">150</span></label>
      <input id="minDelay" type="range" min="0" max="2000" value="150" />
    </div>

    <div class="row">
      <label>遅延の上限 (max ms): <span id="maxLabel">1200</span></label>
      <input id="maxDelay" type="range" min="0" max="3000" value="1200" />
    </div>

    <div class="row">
      <label>ゆらぎの速さ (Hz): <span id="speedLabel">0.25</span></label>
      <input id="speed" type="range" min="1" max="300" value="25" />
    </div>

    <div class="row">
      <label>色ズレの最大量 (px): <span id="rgbMaxLabel">36</span></label>
      <input id="rgbMax" type="range" min="0" max="120" value="36" />
    </div>

    <div class="row">
      <label>色ズレの強さ (0〜1): <span id="rgbPowerLabel">0.85</span></label>
      <input id="rgbPower" type="range" min="0" max="100" value="85" />
    </div>

    <button id="toggle">ゆらぎ: ON（タップで切替）</button>
    <div style="opacity:0.7; font-size:12px; margin-top:6px;">
      ※遅延maxを大きくすると酔いやすい。まず max 800〜1500ms 推奨
    </div>
  </div>

<script>
(async () => {
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d', { alpha:false });

  const msNow = document.getElementById('msNow');
  const rgbNow = document.getElementById('rgbNow');

  const minDelayEl = document.getElementById('minDelay');
  const maxDelayEl = document.getElementById('maxDelay');
  const speedEl = document.getElementById('speed');
  const rgbMaxEl = document.getElementById('rgbMax');
  const rgbPowerEl = document.getElementById('rgbPower');

  const minLabel = document.getElementById('minLabel');
  const maxLabel = document.getElementById('maxLabel');
  const speedLabel = document.getElementById('speedLabel');
  const rgbMaxLabel = document.getElementById('rgbMaxLabel');
  const rgbPowerLabel = document.getElementById('rgbPowerLabel');

  const toggleBtn = document.getElementById('toggle');
  let wobbleOn = true;

  function resize() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    cv.width = Math.floor(innerWidth * dpr);
    cv.height = Math.floor(innerHeight * dpr);
    // オフスクリーンも追従
    off1.width = cv.width; off1.height = cv.height;
    off2.width = cv.width; off2.height = cv.height;
  }
  addEventListener('resize', resize);

  // ---- オフスクリーン（使い回し） ----
  const off1 = document.createElement('canvas');
  const off2 = document.createElement('canvas');
  const o1 = off1.getContext('2d', { alpha:true });
  const o2 = off2.getContext('2d', { alpha:true });

  resize();

  // ---- カメラ（背面） ----
  const video = document.createElement('video');
  video.playsInline = true;
  video.muted = true;

  const stream = await navigator.mediaDevices.getUserMedia({
    video: { facingMode: "environment" },
    audio: false
  });
  video.srcObject = stream;
  await video.play();

  // ---- UI反映 ----
  function refreshLabels(){
    let minMs = Number(minDelayEl.value);
    let maxMs = Number(maxDelayEl.value);
    if (minMs > maxMs) [minMs, maxMs] = [maxMs, minMs];
    minLabel.textContent = String(minMs);
    maxLabel.textContent = String(maxMs);

    const hz = Number(speedEl.value) / 100; // 0.01..3.00
    speedLabel.textContent = hz.toFixed(2);

    rgbMaxLabel.textContent = String(Number(rgbMaxEl.value));
    rgbPowerLabel.textContent = (Number(rgbPowerEl.value)/100).toFixed(2);
  }
  minDelayEl.addEventListener('input', refreshLabels);
  maxDelayEl.addEventListener('input', refreshLabels);
  speedEl.addEventListener('input', refreshLabels);
  rgbMaxEl.addEventListener('input', refreshLabels);
  rgbPowerEl.addEventListener('input', refreshLabels);
  refreshLabels();

  toggleBtn.addEventListener('click', () => {
    wobbleOn = !wobbleOn;
    toggleBtn.textContent = `ゆらぎ: ${wobbleOn ? "ON" : "OFF（固定）"}（タップで切替）`;
  });

  // ---- スムーズランダム（曲線） ----
  let n0 = Math.random();
  let n1 = Math.random();
  let lastStepT = performance.now();
  let stepInterval = 1000;

  function smoothstep(t){ return t * t * (3 - 2 * t); }

  function getWobble01(now){
    const hz = Number(speedEl.value) / 100; // 0.01..3.00
    stepInterval = 1 / Math.max(0.01, hz) * 1000;

    while ((now - lastStepT) > stepInterval) {
      lastStepT += stepInterval;
      n0 = n1;
      n1 = Math.random();
    }

    const t = Math.min(1, Math.max(0, (now - lastStepT) / stepInterval));
    return n0 + (n1 - n0) * smoothstep(t);
  }

  // ---- フレームキュー ----
  const queue = []; // {t, img: ImageBitmap}
  const maxHoldMs = 6000;

  async function captureFrame(){
    const bmp = await createImageBitmap(video);
    queue.push({ t: performance.now(), img: bmp });

    const now = performance.now();
    while (queue.length && (now - queue[0].t) > maxHoldMs) {
      queue[0].img.close?.();
      queue.shift();
    }
  }

  function currentDelayMs(now){
    let minMs = Number(minDelayEl.value);
    let maxMs = Number(maxDelayEl.value);
    if (minMs > maxMs) [minMs, maxMs] = [maxMs, minMs];

    if (!wobbleOn) return Math.round((minMs + maxMs) / 2);

    const r = getWobble01(now);
    return Math.round(minMs + (maxMs - minMs) * r);
  }

  // 遅延に応じた「バグ度」0..1（後半で強く）
  function bugAmount(delayMs){
    let minMs = Number(minDelayEl.value);
    let maxMs = Number(maxDelayEl.value);
    if (minMs > maxMs) [minMs, maxMs] = [maxMs, minMs];

    const denom = Math.max(1, (maxMs - minMs));
    let a = (delayMs - minMs) / denom;
    a = Math.max(0, Math.min(1, a));
    return a * a; // 0..1
  }

  // ---- 強い色ズレ：着色したコピーを重ねる ----
  // 1) ずらして描く
  // 2) source-in で「形はそのまま、色だけ塗る」
  // 3) screen でベースに加算合成
  function drawTintedCopy(offCtx, img, dx, dy, tintRGBA){
    const w = cv.width, h = cv.height;
    offCtx.globalCompositeOperation = 'source-over';
    offCtx.clearRect(0, 0, w, h);

    offCtx.drawImage(img, dx, dy, w, h);
    offCtx.globalCompositeOperation = 'source-in';
    offCtx.fillStyle = tintRGBA;
    offCtx.fillRect(0, 0, w, h);
    offCtx.globalCompositeOperation = 'source-over';
  }

  function drawWithStrongRgbSplit(img, shiftPx, strength01){
    const w = cv.width, h = cv.height;

    // ベース
    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = 1.0;
    ctx.drawImage(img, 0, 0, w, h);

    if (shiftPx <= 0.1 || strength01 <= 0.01) return;

    // 赤コピー（右に）
    drawTintedCopy(o1, img, +shiftPx, 0, `rgba(255,0,0,${strength01})`);
    // シアン（青+緑）コピー（左に）※赤と補色でズレが分かりやすい
    drawTintedCopy(o2, img, -shiftPx, 0, `rgba(0,255,255,${strength01})`);

    ctx.globalCompositeOperation = 'screen';
    ctx.globalAlpha = 1.0;
    ctx.drawImage(off1, 0, 0);
    ctx.drawImage(off2, 0, 0);

    ctx.globalCompositeOperation = 'source-over';
  }

  async function loop(){
    await captureFrame();

    const now = performance.now();
    const delayMs = currentDelayMs(now);
    msNow.textContent = String(delayMs);

    const a = bugAmount(delayMs); // 0..1
    const dpr = Math.max(1, window.devicePixelRatio || 1);

    const rgbMax = Number(rgbMaxEl.value) * dpr;
    const shiftPx = rgbMax * a;
    rgbNow.textContent = (shiftPx / dpr).toFixed(1);

    const strength = (Number(rgbPowerEl.value)/100) * (0.15 + 0.85*a); 
    // 遅延が小さい時でもほんの少し出る。遅延が大きいと一気に強くなる。

    const targetTime = now - delayMs;
    while (queue.length >= 2 && queue[1].t <= targetTime) {
      queue[0].img.close?.();
      queue.shift();
    }

    const frame = queue[0]?.img;
    if (frame) drawWithStrongRgbSplit(frame, shiftPx, strength);

    requestAnimationFrame(() => loop().catch(console.error));
  }

  loop().catch(console.error);
})();
</script>
</body>
</html>




